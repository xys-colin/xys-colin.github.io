<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.0.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.4/css/all.min.css" integrity="sha256-mUZM63G8m73Mcidfrv5E+Y61y7a12O5mW4ezU3bxqW4=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Gemini","darkmode":false,"version":"8.9.0","exturl":false,"sidebar":{"position":"left","display":"always","offset":12,"b2t":false,"scrollpercent":true},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>
<meta name="description" content="一. 核心概念Elasticsearch中的一些概念与MySQL中的可以类比,如下图:">
<meta property="og:type" content="article">
<meta property="og:title" content="Elasticsearch进阶">
<meta property="og:url" content="http://example.com/2021/11/01/Elasticsearch%E8%BF%9B%E9%98%B6/index.html">
<meta property="og:site_name" content="xys-colin的博客">
<meta property="og:description" content="一. 核心概念Elasticsearch中的一些概念与MySQL中的可以类比,如下图:">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/2021/11/01/Elasticsearch%E8%BF%9B%E9%98%B6/es%E6%A6%82%E5%BF%B5%E5%AF%B9%E6%AF%94.png">
<meta property="og:image" content="http://example.com/2021/11/01/Elasticsearch%E8%BF%9B%E9%98%B6/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E7%AE%80%E4%BB%8B.png">
<meta property="og:image" content="http://example.com/2021/11/01/Elasticsearch%E8%BF%9B%E9%98%B6/node1.png">
<meta property="og:image" content="http://example.com/2021/11/01/Elasticsearch%E8%BF%9B%E9%98%B6/cluster.png">
<meta property="og:image" content="http://example.com/2021/11/01/Elasticsearch%E8%BF%9B%E9%98%B6/node2.png">
<meta property="og:image" content="http://example.com/2021/11/01/Elasticsearch%E8%BF%9B%E9%98%B6/node3.png">
<meta property="og:image" content="http://example.com/2021/11/01/Elasticsearch%E8%BF%9B%E9%98%B6/guzhang.png">
<meta property="og:image" content="http://example.com/2021/11/01/Elasticsearch%E8%BF%9B%E9%98%B6/coordinate_node.png">
<meta property="og:image" content="http://example.com/2021/11/01/Elasticsearch%E8%BF%9B%E9%98%B6/data_write.png">
<meta property="og:image" content="http://example.com/2021/11/01/Elasticsearch%E8%BF%9B%E9%98%B6/data_read.png">
<meta property="og:image" content="http://example.com/2021/11/01/Elasticsearch%E8%BF%9B%E9%98%B6/data_update.png">
<meta property="article:published_time" content="2021-11-01T07:15:54.000Z">
<meta property="article:modified_time" content="2022-02-01T15:11:05.528Z">
<meta property="article:author" content="xys-colin">
<meta property="article:tag" content="Elasticsearch">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/2021/11/01/Elasticsearch%E8%BF%9B%E9%98%B6/es%E6%A6%82%E5%BF%B5%E5%AF%B9%E6%AF%94.png">


<link rel="canonical" href="http://example.com/2021/11/01/Elasticsearch%E8%BF%9B%E9%98%B6/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"http://example.com/2021/11/01/Elasticsearch%E8%BF%9B%E9%98%B6/","path":"2021/11/01/Elasticsearch进阶/","title":"Elasticsearch进阶"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Elasticsearch进阶 | xys-colin的博客</title>
  





  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">xys-colin的博客</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">穿越...</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li>
        <li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li>
        <li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li>
        <li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li>
        <li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%80-%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5"><span class="nav-number">1.</span> <span class="nav-text">一. 核心概念</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-%E7%B4%A2%E5%BC%95-Index"><span class="nav-number">1.1.</span> <span class="nav-text">1.1 索引(Index)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-%E7%B1%BB%E5%9E%8B-Type"><span class="nav-number">1.2.</span> <span class="nav-text">1.2 类型(Type)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-3-%E6%96%87%E6%A1%A3-Document"><span class="nav-number">1.3.</span> <span class="nav-text">1.3 文档(Document)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-4-%E5%AD%97%E6%AE%B5-Field"><span class="nav-number">1.4.</span> <span class="nav-text">1.4 字段(Field)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-5-%E6%98%A0%E5%B0%84-Mapping"><span class="nav-number">1.5.</span> <span class="nav-text">1.5 映射(Mapping)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-6-%E5%88%86%E7%89%87-Shards"><span class="nav-number">1.6.</span> <span class="nav-text">1.6 分片(Shards)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-7-%E5%89%AF%E6%9C%AC-Replicas"><span class="nav-number">1.7.</span> <span class="nav-text">1.7 副本(Replicas)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-8-%E5%88%86%E9%85%8D-Allocation"><span class="nav-number">1.8.</span> <span class="nav-text">1.8 分配(Allocation)</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8C-%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E7%AE%80%E4%BB%8B"><span class="nav-number">2.</span> <span class="nav-text">二. 系统架构简介</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-%E5%8D%95%E8%8A%82%E7%82%B9%E9%9B%86%E7%BE%A4"><span class="nav-number">2.1.</span> <span class="nav-text">2.1 单节点集群</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-%E6%95%85%E9%9A%9C%E8%BD%AC%E7%A7%BB"><span class="nav-number">2.2.</span> <span class="nav-text">2.2 故障转移</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-%E6%B0%B4%E5%B9%B3%E6%89%A9%E5%AE%B9"><span class="nav-number">2.3.</span> <span class="nav-text">2.3 水平扩容</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-4-%E6%95%85%E9%9A%9C%E5%BA%94%E5%AF%B9"><span class="nav-number">2.4.</span> <span class="nav-text">2.4 故障应对</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%89-%E8%B7%AF%E7%94%B1%E4%B8%8E%E5%88%86%E7%89%87"><span class="nav-number">3.</span> <span class="nav-text">三. 路由与分片</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-%E8%B7%AF%E7%94%B1%E8%AE%A1%E7%AE%97"><span class="nav-number">3.1.</span> <span class="nav-text">3.1 路由计算</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-%E5%88%86%E7%89%87%E6%8E%A7%E5%88%B6"><span class="nav-number">3.2.</span> <span class="nav-text">3.2 分片控制</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9B%9B-%E6%95%B0%E6%8D%AE%E6%93%8D%E4%BD%9C"><span class="nav-number">4.</span> <span class="nav-text">四. 数据操作</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#4-1-%E6%95%B0%E6%8D%AE%E5%86%99%E6%B5%81%E7%A8%8B"><span class="nav-number">4.1.</span> <span class="nav-text">4.1 数据写流程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-2-%E6%95%B0%E6%8D%AE%E8%AF%BB%E6%B5%81%E7%A8%8B"><span class="nav-number">4.2.</span> <span class="nav-text">4.2 数据读流程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-3-%E6%95%B0%E6%8D%AE%E6%9B%B4%E6%96%B0%E6%B5%81%E7%A8%8B"><span class="nav-number">4.3.</span> <span class="nav-text">4.3 数据更新流程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#4-3-1-%E6%9B%B4%E6%96%B0%E6%B5%81%E7%A8%8B"><span class="nav-number">4.3.1.</span> <span class="nav-text">4.3.1 更新流程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-3-2-%E6%89%B9%E9%87%8F%E6%93%8D%E4%BD%9C%E6%B5%81%E7%A8%8B"><span class="nav-number">4.3.2.</span> <span class="nav-text">4.3.2 批量操作流程</span></a></li></ol></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="xys-colin"
      src="/images/avatar.jpeg">
  <p class="site-author-name" itemprop="name">xys-colin</p>
  <div class="site-description" itemprop="description">个人技术博客</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">6</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">分类</span>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/11/01/Elasticsearch%E8%BF%9B%E9%98%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="xys-colin">
      <meta itemprop="description" content="个人技术博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="xys-colin的博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Elasticsearch进阶
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-11-01 15:15:54" itemprop="dateCreated datePublished" datetime="2021-11-01T15:15:54+08:00">2021-11-01</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-02-01 23:11:05" itemprop="dateModified" datetime="2022-02-01T23:11:05+08:00">2022-02-01</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Elasticsearch/" itemprop="url" rel="index"><span itemprop="name">Elasticsearch</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <h2 id="一-核心概念"><a href="#一-核心概念" class="headerlink" title="一. 核心概念"></a>一. 核心概念</h2><p>Elasticsearch中的一些概念与MySQL中的可以类比,如下图:</p>
<img src="/2021/11/01/Elasticsearch%E8%BF%9B%E9%98%B6/es%E6%A6%82%E5%BF%B5%E5%AF%B9%E6%AF%94.png" class="">

<span id="more"></span>

<h3 id="1-1-索引-Index"><a href="#1-1-索引-Index" class="headerlink" title="1.1 索引(Index)"></a>1.1 索引(Index)</h3><p>一个索引就是一个拥有几分相似特征的文档的集合。比如说，你可以有一个客户数据的索引，另一个产品目录的索引，还有一个订单数据的索引。一个索引由一个名字来标识（必须全部是小写字母），并且当我们要对这个索引中的文档进行索引、搜索、更新和删除（CRUD）的时候，都要使用到这个名字。在一个集群中，可以定义任意多的索引。能搜索的数据必须索引，这样的好处是可以提高查询速度，比如：新华字典前面的目录就是索引的意思，目录可以提高查询速度。<strong>在es中一个索引可以类比为MySQL中的一个数据库</strong></p>
<h3 id="1-2-类型-Type"><a href="#1-2-类型-Type" class="headerlink" title="1.2 类型(Type)"></a>1.2 类型(Type)</h3><p>在一个索引中, 你可以定义一种或多种类型.</p>
<p>一个类型是你的索引的一个逻辑上的分类/分区, 其语义完全由你来定义. 通常, 会为具有一组共同字段的文档定义一个类型. 不同的版本, 类型发生了不同的变化.</p>
<table>
<thead>
<tr>
<th>版本</th>
<th align="center">Type</th>
</tr>
</thead>
<tbody><tr>
<td>5.x</td>
<td align="center">支持多种 type</td>
</tr>
<tr>
<td>6.x</td>
<td align="center">只能有一种 type</td>
</tr>
<tr>
<td>7.x</td>
<td align="center">默认不再支持自定义索引类型（默认类型为： _doc）</td>
</tr>
</tbody></table>
<h3 id="1-3-文档-Document"><a href="#1-3-文档-Document" class="headerlink" title="1.3 文档(Document)"></a>1.3 文档(Document)</h3><p>一个文档是一个可被索引的基础信息单元，也就是一条数据。比如：你可以拥有某一个客户的文档，某一个产品的一个文档，当然，也可以拥有某个订单的一个文档。文档以 JSON（Javascript Object Notation）格式来表示，而 JSON 是一个到处存在的互联网数据交互格式。</p>
<p>在一个 index/type 里面，你可以存储任意多的文档。</p>
<h3 id="1-4-字段-Field"><a href="#1-4-字段-Field" class="headerlink" title="1.4 字段(Field)"></a>1.4 字段(Field)</h3><p>相当于是数据表的字段，对文档数据根据不同属性进行的分类标识。</p>
<h3 id="1-5-映射-Mapping"><a href="#1-5-映射-Mapping" class="headerlink" title="1.5 映射(Mapping)"></a>1.5 映射(Mapping)</h3><p>mapping 是处理数据的方式和规则方面做一些限制，如：某个字段的数据类型、默认值、分析器、是否被索引等等。这些都是映射里面可以设置的，其它就是处理 ES 里面数据的一些使用规则设置也叫做映射，按着最优规则处理数据对性能提高很大，因此才需要建立映射，并且需要思考如何建立映射才能对性能更好。</p>
<h3 id="1-6-分片-Shards"><a href="#1-6-分片-Shards" class="headerlink" title="1.6 分片(Shards)"></a>1.6 分片(Shards)</h3><p>一个索引可以存储超出单个节点硬件限制的大量数据。比如，一个具有 10 亿文档数据的索引占据 1TB 的磁盘空间，而任一节点都可能没有这样大的磁盘空间。 或者单个节点处理搜索请求，响应太慢。为了解决这个问题，<strong>Elasticsearch 提供了将索引划分成多份的能力，每一份就称之为分片。</strong>当你创建一个索引的时候，你可以指定你想要的分片的数量。<strong>每个分片本身也是一个功能完善并且独立的“索引”</strong>，这个“索引”可以被放置到集群中的任何节点上。</p>
<p>分片很重要，主要有两方面的原因：</p>
<ol>
<li>允许你水平分割 / 扩展你的内容容量。</li>
<li>允许你在分片之上进行分布式的、并行的操作，进而提高性能/吞吐量。</li>
</ol>
<p>至于一个分片怎样分布，它的文档怎样聚合和搜索请求，是完全由 Elasticsearch 管理的，对于作为用户的你来说，这些都是透明的，无需过分关心。</p>
<p>被混淆的概念是，一个 Lucene 索引 我们在 Elasticsearch 称作 分片 。 一个Elasticsearch 索引 是分片的集合。 当 Elasticsearch 在索引中搜索的时候， 他发送查询到每一个属于索引的分片（Lucene 索引），然后合并每个分片的结果到一个全局的结果集。</p>
<h3 id="1-7-副本-Replicas"><a href="#1-7-副本-Replicas" class="headerlink" title="1.7 副本(Replicas)"></a>1.7 副本(Replicas)</h3><p>在一个网络 / 云的环境里，失败随时都可能发生，在某个分片/节点不知怎么的就处于离线状态，或者由于任何原因消失了，这种情况下，有一个故障转移机制是非常有用并且是强烈推荐的。为此目的， Elasticsearch 允许你创建分片的一份或多份拷贝，这些拷贝叫做复制分片(副本)。</p>
<p>复制分片之所以重要，有两个主要原因：</p>
<ul>
<li>在分片/节点失败的情况下，<strong>提供了高可用性</strong>。因为这个原因，注意到复制分片从不与原/主要（original/primary）分片置于同一节点上是非常重要的。</li>
<li>扩展你的搜索量/吞吐量，因为搜索可以在所有的副本上并行运行。</li>
</ul>
<p>总之，每个索引可以被分成多个分片。一个索引也可以被复制 0 次（意思是没有复制）或多次。一旦复制了，每个索引就有了主分片（作为复制源的原来的分片）和复制分片（主分片的拷贝）之别。分片和复制的数量可以在索引创建的时候指定。<strong>在索引创建之后，你可以在任何时候动态地改变复制的数量，但是你事后不能改变分片的数量。</strong></p>
<p>默认情况下，Elasticsearch 中的每个索引被分片 1 个主分片和 1 个复制，这意味着，如果你的集群中至少有两个节点，你的索引将会有 1 个主分片和另外 1 个复制分片（1 个完全拷贝），这样的话每个索引总共就有 2 个分片， 我们需要根据索引需要确定分片个数。</p>
<h3 id="1-8-分配-Allocation"><a href="#1-8-分配-Allocation" class="headerlink" title="1.8 分配(Allocation)"></a>1.8 分配(Allocation)</h3><p>将分片分配给某个节点的过程，包括分配主分片或者副本。如果是副本，还包含从主分片复制数据的过程。这个过程是由 master 节点完成的。</p>
<h2 id="二-系统架构简介"><a href="#二-系统架构简介" class="headerlink" title="二. 系统架构简介"></a>二. 系统架构简介</h2><img src="/2021/11/01/Elasticsearch%E8%BF%9B%E9%98%B6/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E7%AE%80%E4%BB%8B.png" class="">

<p>一个运行中的 Elasticsearch 实例称为一个节点，而集群是由一个或者多个拥有相同cluster.name 配置的节点组成， 它们共同承担数据和负载的压力。当有节点加入集群中或者从集群中移除节点时，集群将会重新平均分布所有的数据。<br>当一个节点被选举成为主节点时， 它将负责管理集群范围内的所有变更，例如增加、删除索引，或者增加、删除节点等。 而主节点并不需要涉及到文档级别的变更和搜索等操作，所以当集群只拥有一个主节点的情况下，即使流量的增加它也不会成为瓶颈。 任何节点都可以成为主节点。我们的示例集群就只有一个节点，所以它同时也成为了主节点。<br>作为用户，我们可以将请求发送到集群中的任何节点 ，包括主节点。 每个节点都知道任意文档所处的位置，并且能够将我们的请求直接转发到存储我们所需文档的节点。 无论我们将请求发送到哪个节点，它都能负责从各个包含我们所需文档的节点收集回数据，并将最终结果返回給客户端。 Elasticsearch 对这一切的管理都是透明的。</p>
<h3 id="2-1-单节点集群"><a href="#2-1-单节点集群" class="headerlink" title="2.1 单节点集群"></a>2.1 单节点集群</h3><p>假如我们在包含一个空节点的集群内创建名为users的索引,我们将分配 3个主分片和一份副本（每个主分片拥有一个副本分片）。</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#PUT http:<span class="comment">//127.0.0.1:9300/users</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;settings&quot;</span> : &#123;</span><br><span class="line">        <span class="attr">&quot;number_of_shards&quot;</span> : <span class="number">3</span>,</span><br><span class="line">        <span class="attr">&quot;number_of_replicas&quot;</span> : <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>集群现在是拥有一个索引的单节点集群。所有 3 个主分片都被分配在 node-1 。</p>
<img src="/2021/11/01/Elasticsearch%E8%BF%9B%E9%98%B6/node1.png" class="">

<p>通过 elasticsearch-head 插件（一个Chrome插件）查看集群情况 。</p>
<img src="/2021/11/01/Elasticsearch%E8%BF%9B%E9%98%B6/cluster.png" class="">

<ul>
<li>集群健康值:yellow( 3 of 6 )：表示当前集群的全部主分片都正常运行，但是副本分片没有全部处在正常状态。</li>
<li>绿色的三个主分片表示正常(<strong>黑色框加粗表示主分片</strong>)</li>
<li>灰色的是3个副本分片都是Unassigned, 它们都没有被分配到任何节点。 在同 一个节点上既保存原始数据又保存副本是没有意义的，因为一旦失去了那个节点，我们也将丢失该节点 上的所有副本数据。</li>
</ul>
<p><strong>当前集群是可以正常运行的，但存在丢失数据的风险。</strong></p>
<h3 id="2-2-故障转移"><a href="#2-2-故障转移" class="headerlink" title="2.2 故障转移"></a>2.2 故障转移</h3><p>当集群中只有一个节点在运行时，意味着会有一个单点故障问题——没有冗余。 幸运的是，我们只需再启动一个节点即可防止数据丢失。当你在同一台机器上启动了第二个节点时，只要它和第一个节点有同样的 cluster.name 配置，它就会自动发现集群并加入到其中。但是在不同机器上启动节点的时候，为了加入到同一集群，你需要配置一个可连接到的单播主机列表。之所以配置为使用单播发现，以防止节点无意中加入集群。只有在同一台机器上运行的节点才会自动组成集群。</p>
<p>如果启动了第二个节点，集群将会拥有两个节点 : 所有主分片和副本分片都重新分配 。</p>
<img src="/2021/11/01/Elasticsearch%E8%BF%9B%E9%98%B6/node2.png" class="">

<ul>
<li>集群健康值:green( 3 of 6 )：表示所有 6 个分片（包括 3 个主分片和 3 个副本分片）都在正常运行。</li>
<li>第二个节点加入到集群后， 3 个副本分片将会分配到这个节点上——每 个主分片对应一个副本分片。这意味着当集群内任何一个节点出现问题时，我们的数据都完好无损。所 有新近被索引的文档都将会保存在主分片上，然后被并行的复制到对应的副本分片上。这就保证了我们 既可以从主分片又可以从副本分片上获得文档。</li>
</ul>
<h3 id="2-3-水平扩容"><a href="#2-3-水平扩容" class="headerlink" title="2.3 水平扩容"></a>2.3 水平扩容</h3><p>当启动了第三个节点，我们的集群将会拥有三个节点的集群 : 为了分散负载而对分片进行重新分配 。</p>
<img src="/2021/11/01/Elasticsearch%E8%BF%9B%E9%98%B6/node3.png" class="">

<p>Node 1 和 Node 2 上各有一个分片被迁移到了新的 Node 3 节点，现在每个节点上都拥有 2 个分片， 而不是之前的 3 个。 这表示每个节点的硬件资源（CPU, RAM, I/O）将被更少的分片所共享，每个分片 的性能将会得到提升。</p>
<p>分片是一个功能完整的搜索引擎，它拥有使用一个节点上的所有资源的能力。 我们这个拥有 6 个分 片（3 个主分片和 3 个副本分片）的索引可以最大扩容到 6 个节点，每个节点上存在一个分片，并且每个 分片拥有所在节点的全部资源。</p>
<p><strong>但是如果我们想要扩容超过 6 个节点怎么办呢？</strong></p>
<p>主分片的数目在索引创建时就已经确定了下来。实际上，这个数目定义了这个索引能够<br>存储 的最大数据量。（实际大小取决于你的数据、硬件和使用场景。） 但是，读操作——<br>搜索和返回数据——可以同时被主分片 或 副本分片所处理，所以当你拥有越多的副本分片<br>时，也将拥有越高的吞吐量。在运行中的集群上是可以动态调整副本分片数目的，我们可以按需伸缩集群。让我们把副本数从默认的 1 增加到 2。</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#PUT http:<span class="comment">//127.0.0.1:9300/users/_settings</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;number_of_replicas&quot;</span> : <span class="number">2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-4-故障应对"><a href="#2-4-故障应对" class="headerlink" title="2.4 故障应对"></a>2.4 故障应对</h3><p>我们关闭的节点是一个主节点。而集群必须拥有一个主节点来保证正常工作，所以发生的第一件事情就是选举一个新的主节点： Node 2 。在我们关闭 Node 1 的同时也失去了主分片 1 和 2 ，并且在缺失主分片的时候索引也不能正常工作。 如果此时来检查集群的状况，我们看到的状态将会为 red ：不是所有主分片都在正常工作。</p>
<p>幸运的是，在其它节点上存在着这两个主分片的完整副本， 所以新的主节点立即将这些分片在 Node 2 和 Node 3 上对应的副本分片提升为主分片， 此时集群的状态将会为yellow。这个提升主分片的过程是瞬间发生的，如同按下一个开关一般。</p>
<img src="/2021/11/01/Elasticsearch%E8%BF%9B%E9%98%B6/guzhang.png" class="">

<p>虽然我们拥有所有的三个主分片，但是同时设置了每个主分片需要对应 2 份副本分片，而此<br>时只存在一份副本分片。 所以集群不能为 green 的状态，不过我们不必过于担心：如果我<br>们同样关闭了 Node 2 ，我们的程序 依然 可以保持在不丢任何数据的情况下运行，因为<br>Node 3 为每一个分片都保留着一份副本。如果想回复原来的样子，要确保Node-1的配置文件有如下配置：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">discovery.seed_hosts: [<span class="string">&quot;localhost:9302&quot;</span>, <span class="string">&quot;localhost:9303&quot;</span>]<span class="comment">//其他主机上的es服务器地址</span></span><br></pre></td></tr></table></figure>

<p>重启Node-1, 集群可以将缺失的副本分片再次进行分配，那么集群的状态也将恢复成之前的状态。 如果 Node 1 依然拥有着之前的分片，它将尝试去重用它们，同时仅从主分片复制发生了修改的数据文件。和之前的集群相比，只是 Master 节点切换了。</p>
<h2 id="三-路由与分片"><a href="#三-路由与分片" class="headerlink" title="三. 路由与分片"></a>三. 路由与分片</h2><h3 id="3-1-路由计算"><a href="#3-1-路由计算" class="headerlink" title="3.1 路由计算"></a>3.1 路由计算</h3><p>当索引一个文档的时候，文档会被存储到一个主分片中。 Elasticsearch 如何知道一个文档应该存放到哪个分片中呢？当我们创建文档时，它如何决定这个文档应当被存储在分片 1 还是分片 2 中呢？首先这肯定不会是随机的，否则将来要获取文档的时候我们就不知道从何处寻找了。实际上，这个过程是根据下面这个公式决定的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shard = hash(routing) % number_of_primary_shards</span><br></pre></td></tr></table></figure>

<blockquote>
<p>routing 是一个可变值，默认是文档的 _id ，也可以设置成一个自定义的值。 routing 通过hash 函数生成一个数字，然后这个数字再除以 number_of_primary_shards （主分片的数量）后得到余数 。这个分布在 0 到 number_of_primary_shards-1 之间的余数，就是我们所寻求的文档所在分片的位置。</p>
</blockquote>
<p>这就解释了为什么我们要在创建索引的时候就确定好主分片的数量并且永远不会改变这个数量: 因为如果数量变化了，那么所有之前路由的值都会无效，文档也再也找不到了。</p>
<p>所有的文档API ( get . index . delete 、 bulk , update以及 mget ）都接受一个叫做routing 的路由参数，通过这个参数我们可以自定义文档到分片的映射。一个自定义的路由参数可以用来确保所有相关的文档, 例如所有属于同一个用户的文档——都被存储到同一个分片中。</p>
<h3 id="3-2-分片控制"><a href="#3-2-分片控制" class="headerlink" title="3.2 分片控制"></a>3.2 分片控制</h3><p>我们可以发送请求到集群中的任一节点。每个节点都有能力处理任意请求。每个节点都知道集群中任一文档位置，所以可以直接将请求转发到需要的节点上。在下面的例子中，如果将所有的请求发送到Node 1001，我们将其称为协调节点<strong>coordinating node</strong>。</p>
<img src="/2021/11/01/Elasticsearch%E8%BF%9B%E9%98%B6/coordinate_node.png" class="">

<p>当发送请求的时候， 为了扩展负载，更好的做法是轮询集群中所有的节点。</p>
<h2 id="四-数据操作"><a href="#四-数据操作" class="headerlink" title="四. 数据操作"></a>四. 数据操作</h2><h3 id="4-1-数据写流程"><a href="#4-1-数据写流程" class="headerlink" title="4.1 数据写流程"></a>4.1 数据写流程</h3><p>新建、索引和删除请求都是写操作， 必须在主分片上面完成之后才能被复制到相关的副本分片。</p>
<img src="/2021/11/01/Elasticsearch%E8%BF%9B%E9%98%B6/data_write.png" class="">

<p>在客户端收到成功响应时，文档变更已经在主分片和所有副本分片执行完成，变更是安全的。有一些可选的<strong>请求参数</strong>允许您影响这个过程，可能以数据安全为代价提升性能。这些选项很少使用，因为 Elasticsearch 已经很快，但是为了完整起见， 请参考下文：</p>
<ol>
<li><p>consistency</p>
<blockquote>
<p>即一致性。在默认设置下，即使仅仅是在试图执行一个写操作之前，主分片都会要求必须要有规定数量quorum（或者换种说法，也即必须要有大多数）的分片副本处于活跃可用状态，才会去执行写操作（其中分片副本 可以是主分片或者副本分片）。这是为了避免在发生网络分区故障（network partition）的时候进行写操作，进而导致数据不一致。 规定数量即： <strong>int((primary + number_of_replicas) / 2 ) + 1</strong></p>
</blockquote>
<pre><code>  consistency 参数的值可以设为：
      one ：只要主分片状态 ok 就允许执行写操作。
      all：必须要主分片和所有副本分片的状态没问题才允许执行写操作。
      quorum：默认值为quorum , 即大多数的分片副本状态没问题就允许执行写操作。
</code></pre>
<p>  注意，规定数量的计算公式中number_of_replicas指的是在索引设置中的设定副本分片数，而不是指当前处理    活动状态的副本分片数。如果你的索引设置中指定了当前索引拥有3个副本分片，那规定数量的计算结果即：               int((1 primary + 3 replicas) / 2) + 1 = 3，如果此时你只启动两个节点，那么处于活跃状态的分片副本数量就达    不到规定数量，也因此您将无法索引和删除任何文档。</p>
</li>
<li><p>timeout<br>如果没有足够的副本分片会发生什么？Elasticsearch 会等待，希望更多的分片出现。默认情况下，它最多等待 1 分钟。 如果你需要，你可以使用timeout参数使它更早终止：100是100 毫秒，30s是30秒。</p>
</li>
</ol>
<p>新索引默认有1个副本分片，这意味着为满足规定数量应该需要两个活动的分片。 但是，这些默认的设置会阻止我们在单一节点上做任何事情。为了避免这个问题，要求只有当number_of_replicas 大于1的时候，规定数量才会执行。</p>
<h3 id="4-2-数据读流程"><a href="#4-2-数据读流程" class="headerlink" title="4.2 数据读流程"></a>4.2 数据读流程</h3><img src="/2021/11/01/Elasticsearch%E8%BF%9B%E9%98%B6/data_read.png" class="">

<p>在处理读取请求时，协调结点在每次请求的时候都会通过轮询所有的副本分片来达到负载均衡。在文档被检索时，已经被索引的文档可能已经存在于主分片上但是还没有复制到副本分片。 在这种情况下，副本分片可能会报告文档不存在，但是主分片可能成功返回文档。 一旦索引请求成功返回给用户，文档在主分片和副本分片都是可用的。</p>
<h3 id="4-3-数据更新流程"><a href="#4-3-数据更新流程" class="headerlink" title="4.3 数据更新流程"></a>4.3 数据更新流程</h3><h4 id="4-3-1-更新流程"><a href="#4-3-1-更新流程" class="headerlink" title="4.3.1 更新流程"></a>4.3.1 更新流程</h4><p>部分更新一个文档结合了先前说明的读取和写入流程：</p>
<img src="/2021/11/01/Elasticsearch%E8%BF%9B%E9%98%B6/data_update.png" class="">

<ol>
<li>客户端向Node 1发送更新请求。</li>
<li>它将请求转发到主分片所在的Node 3 。</li>
<li>Node 3从主分片检索文档，修改_source字段中的JSON，并且尝试重新索引主分片的文档。如果文档已经被另一个进程修改,它会重试步骤3 ,超过retry_on_conflict次后放弃。</li>
<li>如果 Node 3成功地更新文档，它将新版本的文档并行转发到Node 1和 Node 2上的副本分片，重新建立索引。一旦所有副本分片都返回成功，Node 3向协调节点也返回成功，协调节点向客户端返回成功。</li>
</ol>
<p>当主分片把更改转发到副本分片时， 它不会转发更新请求。 相反，它转发完整文档的新版本。请记住，这些更改将会异步转发到副本分片，并且不能保证它们以发送它们相同的顺序到达。 如果 Elasticsearch 仅转发更改请求，则可能以错误的顺序应用更改，导致得到损坏的文档。</p>
<h4 id="4-3-2-批量操作流程"><a href="#4-3-2-批量操作流程" class="headerlink" title="4.3.2 批量操作流程"></a>4.3.2 批量操作流程</h4><p><strong>mget和 bulk API的模式类似于单文档模式。</strong>区别在于协调节点知道每个文档存在于哪个分片中。它将整个多文档请求分解成每个分片的多文档请求，并且将这些请求并行转发到每个参与节点。</p>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Elasticsearch/" rel="tag"># Elasticsearch</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2021/10/28/ES%E6%8E%A5%E5%8F%A3%E6%93%8D%E4%BD%9C/" rel="prev" title="ES接口操作">
                  <i class="fa fa-chevron-left"></i> ES接口操作
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2022/01/27/vim%E7%A8%8B%E5%BA%8F%E7%BC%96%E8%BE%91%E5%99%A8/" rel="next" title="vim程序编辑器">
                  vim程序编辑器 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">xys-colin</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  
<script src="https://cdn.jsdelivr.net/npm/hexo-generator-searchdb@1.4.0/dist/search.js" integrity="sha256-vXZMYLEqsROAXkEw93GGIvaB2ab+QW6w3+1ahD9nXXA=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>





  





</body>
</html>
