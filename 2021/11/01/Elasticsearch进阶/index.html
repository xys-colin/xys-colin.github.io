<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.0.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.4/css/all.min.css" integrity="sha256-mUZM63G8m73Mcidfrv5E+Y61y7a12O5mW4ezU3bxqW4=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Gemini","darkmode":false,"version":"8.9.0","exturl":false,"sidebar":{"position":"left","display":"always","offset":10,"b2t":false,"scrollpercent":true},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>
<meta name="description" content="一. 核心概念Elasticsearch中的一些概念与MySQL中的可以类比,如下图:">
<meta property="og:type" content="article">
<meta property="og:title" content="Elasticsearch进阶">
<meta property="og:url" content="http://example.com/2021/11/01/Elasticsearch%E8%BF%9B%E9%98%B6/index.html">
<meta property="og:site_name" content="xys-colin的博客">
<meta property="og:description" content="一. 核心概念Elasticsearch中的一些概念与MySQL中的可以类比,如下图:">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/2021/11/01/Elasticsearch%E8%BF%9B%E9%98%B6/es%E6%A6%82%E5%BF%B5%E5%AF%B9%E6%AF%94.png">
<meta property="og:image" content="http://example.com/2021/11/01/Elasticsearch%E8%BF%9B%E9%98%B6/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E7%AE%80%E4%BB%8B.png">
<meta property="og:image" content="http://example.com/2021/11/01/Elasticsearch%E8%BF%9B%E9%98%B6/node1.png">
<meta property="og:image" content="http://example.com/2021/11/01/Elasticsearch%E8%BF%9B%E9%98%B6/cluster.png">
<meta property="og:image" content="http://example.com/2021/11/01/Elasticsearch%E8%BF%9B%E9%98%B6/node2.png">
<meta property="og:image" content="http://example.com/2021/11/01/Elasticsearch%E8%BF%9B%E9%98%B6/node3.png">
<meta property="og:image" content="http://example.com/2021/11/01/Elasticsearch%E8%BF%9B%E9%98%B6/guzhang.png">
<meta property="og:image" content="http://example.com/2021/11/01/Elasticsearch%E8%BF%9B%E9%98%B6/coordinate_node.png">
<meta property="og:image" content="http://example.com/2021/11/01/Elasticsearch%E8%BF%9B%E9%98%B6/data_write.png">
<meta property="og:image" content="http://example.com/2021/11/01/Elasticsearch%E8%BF%9B%E9%98%B6/data_read.png">
<meta property="og:image" content="http://example.com/2021/11/01/Elasticsearch%E8%BF%9B%E9%98%B6/data_update.png">
<meta property="og:image" content="http://example.com/2021/11/01/Elasticsearch%E8%BF%9B%E9%98%B6/data_update1.png">
<meta property="og:image" content="http://example.com/2021/11/01/Elasticsearch%E8%BF%9B%E9%98%B6/data_update2.png">
<meta property="og:image" content="http://example.com/2021/11/01/Elasticsearch%E8%BF%9B%E9%98%B6/daopai.png">
<meta property="og:image" content="http://example.com/2021/11/01/Elasticsearch%E8%BF%9B%E9%98%B6/commit_point.png">
<meta property="og:image" content="http://example.com/2021/11/01/Elasticsearch%E8%BF%9B%E9%98%B6/commit_point1.png">
<meta property="og:image" content="http://example.com/2021/11/01/Elasticsearch%E8%BF%9B%E9%98%B6/commit_point2.png">
<meta property="og:image" content="http://example.com/2021/11/01/Elasticsearch%E8%BF%9B%E9%98%B6/doc.png">
<meta property="og:image" content="http://example.com/2021/11/01/Elasticsearch%E8%BF%9B%E9%98%B6/doc1.png">
<meta property="og:image" content="http://example.com/2021/11/01/Elasticsearch%E8%BF%9B%E9%98%B6/commit_point1.png">
<meta property="og:image" content="http://example.com/2021/11/01/Elasticsearch%E8%BF%9B%E9%98%B6/commit_point3.png">
<meta property="og:image" content="http://example.com/2021/11/01/Elasticsearch%E8%BF%9B%E9%98%B6/commit_point4.png">
<meta property="og:image" content="http://example.com/2021/11/01/Elasticsearch%E8%BF%9B%E9%98%B6/commit_point5.png">
<meta property="og:image" content="http://example.com/2021/11/01/Elasticsearch%E8%BF%9B%E9%98%B6/commit_point6.png">
<meta property="og:image" content="http://example.com/2021/11/01/Elasticsearch%E8%BF%9B%E9%98%B6/commit_point7.png">
<meta property="og:image" content="http://example.com/2021/11/01/Elasticsearch%E8%BF%9B%E9%98%B6/merger.png">
<meta property="og:image" content="http://example.com/2021/11/01/Elasticsearch%E8%BF%9B%E9%98%B6/merger1.png">
<meta property="article:published_time" content="2021-11-01T07:15:54.000Z">
<meta property="article:modified_time" content="2022-02-02T09:13:24.870Z">
<meta property="article:author" content="xys-colin">
<meta property="article:tag" content="Elasticsearch">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/2021/11/01/Elasticsearch%E8%BF%9B%E9%98%B6/es%E6%A6%82%E5%BF%B5%E5%AF%B9%E6%AF%94.png">


<link rel="canonical" href="http://example.com/2021/11/01/Elasticsearch%E8%BF%9B%E9%98%B6/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"http://example.com/2021/11/01/Elasticsearch%E8%BF%9B%E9%98%B6/","path":"2021/11/01/Elasticsearch进阶/","title":"Elasticsearch进阶"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Elasticsearch进阶 | xys-colin的博客</title>
  





  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">xys-colin的博客</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">穿越...</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li>
        <li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li>
        <li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li>
        <li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li>
        <li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%80-%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5"><span class="nav-number">1.</span> <span class="nav-text">一. 核心概念</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-%E7%B4%A2%E5%BC%95-Index"><span class="nav-number">1.1.</span> <span class="nav-text">1.1 索引(Index)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-%E7%B1%BB%E5%9E%8B-Type"><span class="nav-number">1.2.</span> <span class="nav-text">1.2 类型(Type)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-3-%E6%96%87%E6%A1%A3-Document"><span class="nav-number">1.3.</span> <span class="nav-text">1.3 文档(Document)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-4-%E5%AD%97%E6%AE%B5-Field"><span class="nav-number">1.4.</span> <span class="nav-text">1.4 字段(Field)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-5-%E6%98%A0%E5%B0%84-Mapping"><span class="nav-number">1.5.</span> <span class="nav-text">1.5 映射(Mapping)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-6-%E5%88%86%E7%89%87-Shards"><span class="nav-number">1.6.</span> <span class="nav-text">1.6 分片(Shards)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-7-%E5%89%AF%E6%9C%AC-Replicas"><span class="nav-number">1.7.</span> <span class="nav-text">1.7 副本(Replicas)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-8-%E5%88%86%E9%85%8D-Allocation"><span class="nav-number">1.8.</span> <span class="nav-text">1.8 分配(Allocation)</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8C-%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E7%AE%80%E4%BB%8B"><span class="nav-number">2.</span> <span class="nav-text">二. 系统架构简介</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-%E5%8D%95%E8%8A%82%E7%82%B9%E9%9B%86%E7%BE%A4"><span class="nav-number">2.1.</span> <span class="nav-text">2.1 单节点集群</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-%E6%95%85%E9%9A%9C%E8%BD%AC%E7%A7%BB"><span class="nav-number">2.2.</span> <span class="nav-text">2.2 故障转移</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-%E6%B0%B4%E5%B9%B3%E6%89%A9%E5%AE%B9"><span class="nav-number">2.3.</span> <span class="nav-text">2.3 水平扩容</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-4-%E6%95%85%E9%9A%9C%E5%BA%94%E5%AF%B9"><span class="nav-number">2.4.</span> <span class="nav-text">2.4 故障应对</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%89-%E8%B7%AF%E7%94%B1%E4%B8%8E%E5%88%86%E7%89%87"><span class="nav-number">3.</span> <span class="nav-text">三. 路由与分片</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-%E8%B7%AF%E7%94%B1%E8%AE%A1%E7%AE%97"><span class="nav-number">3.1.</span> <span class="nav-text">3.1 路由计算</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-%E5%88%86%E7%89%87%E6%8E%A7%E5%88%B6"><span class="nav-number">3.2.</span> <span class="nav-text">3.2 分片控制</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9B%9B-%E6%95%B0%E6%8D%AE%E6%93%8D%E4%BD%9C"><span class="nav-number">4.</span> <span class="nav-text">四. 数据操作</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#4-1-%E6%95%B0%E6%8D%AE%E5%86%99%E6%B5%81%E7%A8%8B"><span class="nav-number">4.1.</span> <span class="nav-text">4.1 数据写流程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-2-%E6%95%B0%E6%8D%AE%E8%AF%BB%E6%B5%81%E7%A8%8B"><span class="nav-number">4.2.</span> <span class="nav-text">4.2 数据读流程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-3-%E6%95%B0%E6%8D%AE%E6%9B%B4%E6%96%B0%E6%B5%81%E7%A8%8B"><span class="nav-number">4.3.</span> <span class="nav-text">4.3 数据更新流程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#4-3-1-%E6%9B%B4%E6%96%B0%E6%B5%81%E7%A8%8B"><span class="nav-number">4.3.1.</span> <span class="nav-text">4.3.1 更新流程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-3-2-%E6%89%B9%E9%87%8F%E6%93%8D%E4%BD%9C%E6%B5%81%E7%A8%8B"><span class="nav-number">4.3.2.</span> <span class="nav-text">4.3.2 批量操作流程</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%94-%E6%96%87%E6%A1%A3"><span class="nav-number">5.</span> <span class="nav-text">五. 文档</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#5-1-%E5%80%92%E6%8E%92%E7%B4%A2%E5%BC%95"><span class="nav-number">5.1.</span> <span class="nav-text">5.1 倒排索引</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#5-1-1-%E4%B8%8D%E5%8F%AF%E5%8F%98%E7%9A%84%E5%80%92%E6%8E%92%E7%B4%A2%E5%BC%95"><span class="nav-number">5.1.1.</span> <span class="nav-text">5.1.1 不可变的倒排索引</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-1-2-%E5%8A%A8%E6%80%81%E6%9B%B4%E6%96%B0%E7%B4%A2%E5%BC%95"><span class="nav-number">5.1.2.</span> <span class="nav-text">5.1.2 动态更新索引</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-2-%E6%96%87%E6%A1%A3%E5%88%B7%E6%96%B0"><span class="nav-number">5.2.</span> <span class="nav-text">5.2 文档刷新</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#5-2-1-%E8%BF%91%E5%AE%9E%E6%97%B6%E6%90%9C%E7%B4%A2"><span class="nav-number">5.2.1.</span> <span class="nav-text">5.2.1 近实时搜索</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-2-2-%E6%8C%81%E4%B9%85%E5%8C%96%E5%8F%98%E6%9B%B4"><span class="nav-number">5.2.2.</span> <span class="nav-text">5.2.2 持久化变更</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-3-%E6%AE%B5%E5%90%88%E5%B9%B6"><span class="nav-number">5.3.</span> <span class="nav-text">5.3 段合并</span></a></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="xys-colin"
      src="/images/avatar.jpeg">
  <p class="site-author-name" itemprop="name">xys-colin</p>
  <div class="site-description" itemprop="description">个人技术博客</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">11</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">分类</span>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/11/01/Elasticsearch%E8%BF%9B%E9%98%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="xys-colin">
      <meta itemprop="description" content="个人技术博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="xys-colin的博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Elasticsearch进阶
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-11-01 15:15:54" itemprop="dateCreated datePublished" datetime="2021-11-01T15:15:54+08:00">2021-11-01</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-02-02 17:13:24" itemprop="dateModified" datetime="2022-02-02T17:13:24+08:00">2022-02-02</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Elasticsearch/" itemprop="url" rel="index"><span itemprop="name">Elasticsearch</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <h2 id="一-核心概念"><a href="#一-核心概念" class="headerlink" title="一. 核心概念"></a>一. 核心概念</h2><p>Elasticsearch中的一些概念与MySQL中的可以类比,如下图:</p>
<img src="/2021/11/01/Elasticsearch%E8%BF%9B%E9%98%B6/es%E6%A6%82%E5%BF%B5%E5%AF%B9%E6%AF%94.png" class="">

<span id="more"></span>

<h3 id="1-1-索引-Index"><a href="#1-1-索引-Index" class="headerlink" title="1.1 索引(Index)"></a>1.1 索引(Index)</h3><p>一个索引就是一个拥有几分相似特征的文档的集合。比如说，你可以有一个客户数据的索引，另一个产品目录的索引，还有一个订单数据的索引。一个索引由一个名字来标识（必须全部是小写字母），并且当我们要对这个索引中的文档进行索引、搜索、更新和删除（CRUD）的时候，都要使用到这个名字。在一个集群中，可以定义任意多的索引。能搜索的数据必须索引，这样的好处是可以提高查询速度，比如：新华字典前面的目录就是索引的意思，目录可以提高查询速度。<strong>在es中一个索引可以类比为MySQL中的一个数据库</strong></p>
<h3 id="1-2-类型-Type"><a href="#1-2-类型-Type" class="headerlink" title="1.2 类型(Type)"></a>1.2 类型(Type)</h3><p>在一个索引中, 你可以定义一种或多种类型.</p>
<p>一个类型是你的索引的一个逻辑上的分类/分区, 其语义完全由你来定义. 通常, 会为具有一组共同字段的文档定义一个类型. 不同的版本, 类型发生了不同的变化.</p>
<table>
<thead>
<tr>
<th>版本</th>
<th align="center">Type</th>
</tr>
</thead>
<tbody><tr>
<td>5.x</td>
<td align="center">支持多种 type</td>
</tr>
<tr>
<td>6.x</td>
<td align="center">只能有一种 type</td>
</tr>
<tr>
<td>7.x</td>
<td align="center">默认不再支持自定义索引类型（默认类型为： _doc）</td>
</tr>
</tbody></table>
<h3 id="1-3-文档-Document"><a href="#1-3-文档-Document" class="headerlink" title="1.3 文档(Document)"></a>1.3 文档(Document)</h3><p>一个文档是一个可被索引的基础信息单元，也就是一条数据。比如：你可以拥有某一个客户的文档，某一个产品的一个文档，当然，也可以拥有某个订单的一个文档。文档以 JSON（Javascript Object Notation）格式来表示，而 JSON 是一个到处存在的互联网数据交互格式。</p>
<p>在一个 index/type 里面，你可以存储任意多的文档。</p>
<h3 id="1-4-字段-Field"><a href="#1-4-字段-Field" class="headerlink" title="1.4 字段(Field)"></a>1.4 字段(Field)</h3><p>相当于是数据表的字段，对文档数据根据不同属性进行的分类标识。</p>
<h3 id="1-5-映射-Mapping"><a href="#1-5-映射-Mapping" class="headerlink" title="1.5 映射(Mapping)"></a>1.5 映射(Mapping)</h3><p>mapping 是处理数据的方式和规则方面做一些限制，如：某个字段的数据类型、默认值、分析器、是否被索引等等。这些都是映射里面可以设置的，其它就是处理 ES 里面数据的一些使用规则设置也叫做映射，按着最优规则处理数据对性能提高很大，因此才需要建立映射，并且需要思考如何建立映射才能对性能更好。</p>
<h3 id="1-6-分片-Shards"><a href="#1-6-分片-Shards" class="headerlink" title="1.6 分片(Shards)"></a>1.6 分片(Shards)</h3><p>一个索引可以存储超出单个节点硬件限制的大量数据。比如，一个具有 10 亿文档数据的索引占据 1TB 的磁盘空间，而任一节点都可能没有这样大的磁盘空间。 或者单个节点处理搜索请求，响应太慢。为了解决这个问题，<strong>Elasticsearch 提供了将索引划分成多份的能力，每一份就称之为分片。</strong>当你创建一个索引的时候，你可以指定你想要的分片的数量。<strong>每个分片本身也是一个功能完善并且独立的“索引”</strong>，这个“索引”可以被放置到集群中的任何节点上。</p>
<p>分片很重要，主要有两方面的原因：</p>
<ol>
<li>允许你水平分割 / 扩展你的内容容量。</li>
<li>允许你在分片之上进行分布式的、并行的操作，进而提高性能/吞吐量。</li>
</ol>
<p>至于一个分片怎样分布，它的文档怎样聚合和搜索请求，是完全由 Elasticsearch 管理的，对于作为用户的你来说，这些都是透明的，无需过分关心。</p>
<p>被混淆的概念是，一个 Lucene 索引 我们在 Elasticsearch 称作 分片 。 一个Elasticsearch 索引 是分片的集合。 当 Elasticsearch 在索引中搜索的时候， 他发送查询到每一个属于索引的分片（Lucene 索引），然后合并每个分片的结果到一个全局的结果集。</p>
<h3 id="1-7-副本-Replicas"><a href="#1-7-副本-Replicas" class="headerlink" title="1.7 副本(Replicas)"></a>1.7 副本(Replicas)</h3><p>在一个网络 / 云的环境里，失败随时都可能发生，在某个分片/节点不知怎么的就处于离线状态，或者由于任何原因消失了，这种情况下，有一个故障转移机制是非常有用并且是强烈推荐的。为此目的， Elasticsearch 允许你创建分片的一份或多份拷贝，这些拷贝叫做复制分片(副本)。</p>
<p>复制分片之所以重要，有两个主要原因：</p>
<ul>
<li>在分片/节点失败的情况下，<strong>提供了高可用性</strong>。因为这个原因，注意到复制分片从不与原/主要（original/primary）分片置于同一节点上是非常重要的。</li>
<li>扩展你的搜索量/吞吐量，因为搜索可以在所有的副本上并行运行。</li>
</ul>
<p>总之，每个索引可以被分成多个分片。一个索引也可以被复制 0 次（意思是没有复制）或多次。一旦复制了，每个索引就有了主分片（作为复制源的原来的分片）和复制分片（主分片的拷贝）之别。分片和复制的数量可以在索引创建的时候指定。<strong>在索引创建之后，你可以在任何时候动态地改变复制的数量，但是你事后不能改变分片的数量。</strong></p>
<p>默认情况下，Elasticsearch 中的每个索引被分片 1 个主分片和 1 个复制，这意味着，如果你的集群中至少有两个节点，你的索引将会有 1 个主分片和另外 1 个复制分片（1 个完全拷贝），这样的话每个索引总共就有 2 个分片， 我们需要根据索引需要确定分片个数。</p>
<h3 id="1-8-分配-Allocation"><a href="#1-8-分配-Allocation" class="headerlink" title="1.8 分配(Allocation)"></a>1.8 分配(Allocation)</h3><p>将分片分配给某个节点的过程，包括分配主分片或者副本。如果是副本，还包含从主分片复制数据的过程。这个过程是由 master 节点完成的。</p>
<h2 id="二-系统架构简介"><a href="#二-系统架构简介" class="headerlink" title="二. 系统架构简介"></a>二. 系统架构简介</h2><img src="/2021/11/01/Elasticsearch%E8%BF%9B%E9%98%B6/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E7%AE%80%E4%BB%8B.png" class="">

<p>一个运行中的 Elasticsearch 实例称为一个节点，而集群是由一个或者多个拥有相同cluster.name 配置的节点组成， 它们共同承担数据和负载的压力。当有节点加入集群中或者从集群中移除节点时，集群将会重新平均分布所有的数据。<br>当一个节点被选举成为主节点时， 它将负责管理集群范围内的所有变更，例如增加、删除索引，或者增加、删除节点等。 而主节点并不需要涉及到文档级别的变更和搜索等操作，所以当集群只拥有一个主节点的情况下，即使流量的增加它也不会成为瓶颈。 任何节点都可以成为主节点。我们的示例集群就只有一个节点，所以它同时也成为了主节点。<br>作为用户，我们可以将请求发送到集群中的任何节点 ，包括主节点。 每个节点都知道任意文档所处的位置，并且能够将我们的请求直接转发到存储我们所需文档的节点。 无论我们将请求发送到哪个节点，它都能负责从各个包含我们所需文档的节点收集回数据，并将最终结果返回給客户端。 Elasticsearch 对这一切的管理都是透明的。</p>
<h3 id="2-1-单节点集群"><a href="#2-1-单节点集群" class="headerlink" title="2.1 单节点集群"></a>2.1 单节点集群</h3><p>假如我们在包含一个空节点的集群内创建名为users的索引,我们将分配 3个主分片和一份副本（每个主分片拥有一个副本分片）。</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#PUT http:<span class="comment">//127.0.0.1:9300/users</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;settings&quot;</span> : &#123;</span><br><span class="line">        <span class="attr">&quot;number_of_shards&quot;</span> : <span class="number">3</span>,</span><br><span class="line">        <span class="attr">&quot;number_of_replicas&quot;</span> : <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>集群现在是拥有一个索引的单节点集群。所有 3 个主分片都被分配在 node-1 。</p>
<img src="/2021/11/01/Elasticsearch%E8%BF%9B%E9%98%B6/node1.png" class="">

<p>通过 elasticsearch-head 插件（一个Chrome插件）查看集群情况 。</p>
<img src="/2021/11/01/Elasticsearch%E8%BF%9B%E9%98%B6/cluster.png" class="">

<ul>
<li>集群健康值:yellow( 3 of 6 )：表示当前集群的全部主分片都正常运行，但是副本分片没有全部处在正常状态。</li>
<li>绿色的三个主分片表示正常(<strong>黑色框加粗表示主分片</strong>)</li>
<li>灰色的是3个副本分片都是Unassigned, 它们都没有被分配到任何节点。 在同 一个节点上既保存原始数据又保存副本是没有意义的，因为一旦失去了那个节点，我们也将丢失该节点 上的所有副本数据。</li>
</ul>
<p><strong>当前集群是可以正常运行的，但存在丢失数据的风险。</strong></p>
<h3 id="2-2-故障转移"><a href="#2-2-故障转移" class="headerlink" title="2.2 故障转移"></a>2.2 故障转移</h3><p>当集群中只有一个节点在运行时，意味着会有一个单点故障问题——没有冗余。 幸运的是，我们只需再启动一个节点即可防止数据丢失。当你在同一台机器上启动了第二个节点时，只要它和第一个节点有同样的 cluster.name 配置，它就会自动发现集群并加入到其中。但是在不同机器上启动节点的时候，为了加入到同一集群，你需要配置一个可连接到的单播主机列表。之所以配置为使用单播发现，以防止节点无意中加入集群。只有在同一台机器上运行的节点才会自动组成集群。</p>
<p>如果启动了第二个节点，集群将会拥有两个节点 : 所有主分片和副本分片都重新分配 。</p>
<img src="/2021/11/01/Elasticsearch%E8%BF%9B%E9%98%B6/node2.png" class="">

<ul>
<li>集群健康值:green( 3 of 6 )：表示所有 6 个分片（包括 3 个主分片和 3 个副本分片）都在正常运行。</li>
<li>第二个节点加入到集群后， 3 个副本分片将会分配到这个节点上——每 个主分片对应一个副本分片。这意味着当集群内任何一个节点出现问题时，我们的数据都完好无损。所 有新近被索引的文档都将会保存在主分片上，然后被并行的复制到对应的副本分片上。这就保证了我们 既可以从主分片又可以从副本分片上获得文档。</li>
</ul>
<h3 id="2-3-水平扩容"><a href="#2-3-水平扩容" class="headerlink" title="2.3 水平扩容"></a>2.3 水平扩容</h3><p>当启动了第三个节点，我们的集群将会拥有三个节点的集群 : 为了分散负载而对分片进行重新分配 。</p>
<img src="/2021/11/01/Elasticsearch%E8%BF%9B%E9%98%B6/node3.png" class="">

<p>Node 1 和 Node 2 上各有一个分片被迁移到了新的 Node 3 节点，现在每个节点上都拥有 2 个分片， 而不是之前的 3 个。 这表示每个节点的硬件资源（CPU, RAM, I/O）将被更少的分片所共享，每个分片 的性能将会得到提升。</p>
<p>分片是一个功能完整的搜索引擎，它拥有使用一个节点上的所有资源的能力。 我们这个拥有 6 个分 片（3 个主分片和 3 个副本分片）的索引可以最大扩容到 6 个节点，每个节点上存在一个分片，并且每个 分片拥有所在节点的全部资源。</p>
<p><strong>但是如果我们想要扩容超过 6 个节点怎么办呢？</strong></p>
<p>主分片的数目在索引创建时就已经确定了下来。实际上，这个数目定义了这个索引能够<br>存储 的最大数据量。（实际大小取决于你的数据、硬件和使用场景。） 但是，读操作——<br>搜索和返回数据——可以同时被主分片 或 副本分片所处理，所以当你拥有越多的副本分片<br>时，也将拥有越高的吞吐量。在运行中的集群上是可以动态调整副本分片数目的，我们可以按需伸缩集群。让我们把副本数从默认的 1 增加到 2。</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#PUT http:<span class="comment">//127.0.0.1:9300/users/_settings</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;number_of_replicas&quot;</span> : <span class="number">2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-4-故障应对"><a href="#2-4-故障应对" class="headerlink" title="2.4 故障应对"></a>2.4 故障应对</h3><p>我们关闭的节点是一个主节点。而集群必须拥有一个主节点来保证正常工作，所以发生的第一件事情就是选举一个新的主节点： Node 2 。在我们关闭 Node 1 的同时也失去了主分片 1 和 2 ，并且在缺失主分片的时候索引也不能正常工作。 如果此时来检查集群的状况，我们看到的状态将会为 red ：不是所有主分片都在正常工作。</p>
<p>幸运的是，在其它节点上存在着这两个主分片的完整副本， 所以新的主节点立即将这些分片在 Node 2 和 Node 3 上对应的副本分片提升为主分片， 此时集群的状态将会为yellow。这个提升主分片的过程是瞬间发生的，如同按下一个开关一般。</p>
<img src="/2021/11/01/Elasticsearch%E8%BF%9B%E9%98%B6/guzhang.png" class="">

<p>虽然我们拥有所有的三个主分片，但是同时设置了每个主分片需要对应 2 份副本分片，而此<br>时只存在一份副本分片。 所以集群不能为 green 的状态，不过我们不必过于担心：如果我<br>们同样关闭了 Node 2 ，我们的程序 依然 可以保持在不丢任何数据的情况下运行，因为<br>Node 3 为每一个分片都保留着一份副本。如果想回复原来的样子，要确保Node-1的配置文件有如下配置：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">discovery.seed_hosts: [<span class="string">&quot;localhost:9302&quot;</span>, <span class="string">&quot;localhost:9303&quot;</span>]<span class="comment">//其他主机上的es服务器地址</span></span><br></pre></td></tr></table></figure>

<p>重启Node-1, 集群可以将缺失的副本分片再次进行分配，那么集群的状态也将恢复成之前的状态。 如果 Node 1 依然拥有着之前的分片，它将尝试去重用它们，同时仅从主分片复制发生了修改的数据文件。和之前的集群相比，只是 Master 节点切换了。</p>
<h2 id="三-路由与分片"><a href="#三-路由与分片" class="headerlink" title="三. 路由与分片"></a>三. 路由与分片</h2><h3 id="3-1-路由计算"><a href="#3-1-路由计算" class="headerlink" title="3.1 路由计算"></a>3.1 路由计算</h3><p>当索引一个文档的时候，文档会被存储到一个主分片中。 Elasticsearch 如何知道一个文档应该存放到哪个分片中呢？当我们创建文档时，它如何决定这个文档应当被存储在分片 1 还是分片 2 中呢？首先这肯定不会是随机的，否则将来要获取文档的时候我们就不知道从何处寻找了。实际上，这个过程是根据下面这个公式决定的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shard = hash(routing) % number_of_primary_shards</span><br></pre></td></tr></table></figure>

<blockquote>
<p>routing 是一个可变值，默认是文档的 _id ，也可以设置成一个自定义的值。 routing 通过hash 函数生成一个数字，然后这个数字再除以 number_of_primary_shards （主分片的数量）后得到余数 。这个分布在 0 到 number_of_primary_shards-1 之间的余数，就是我们所寻求的文档所在分片的位置。</p>
</blockquote>
<p>这就解释了为什么我们要在创建索引的时候就确定好主分片的数量并且永远不会改变这个数量: 因为如果数量变化了，那么所有之前路由的值都会无效，文档也再也找不到了。</p>
<p>所有的文档API ( get . index . delete 、 bulk , update以及 mget ）都接受一个叫做routing 的路由参数，通过这个参数我们可以自定义文档到分片的映射。一个自定义的路由参数可以用来确保所有相关的文档, 例如所有属于同一个用户的文档——都被存储到同一个分片中。</p>
<h3 id="3-2-分片控制"><a href="#3-2-分片控制" class="headerlink" title="3.2 分片控制"></a>3.2 分片控制</h3><p>我们可以发送请求到集群中的任一节点。每个节点都有能力处理任意请求。每个节点都知道集群中任一文档位置，所以可以直接将请求转发到需要的节点上。在下面的例子中，如果将所有的请求发送到Node 1001，我们将其称为协调节点<strong>coordinating node</strong>。</p>
<img src="/2021/11/01/Elasticsearch%E8%BF%9B%E9%98%B6/coordinate_node.png" class="">

<p>当发送请求的时候， 为了扩展负载，更好的做法是轮询集群中所有的节点。</p>
<h2 id="四-数据操作"><a href="#四-数据操作" class="headerlink" title="四. 数据操作"></a>四. 数据操作</h2><h3 id="4-1-数据写流程"><a href="#4-1-数据写流程" class="headerlink" title="4.1 数据写流程"></a>4.1 数据写流程</h3><p>新建、索引和删除请求都是写操作， 必须在主分片上面完成之后才能被复制到相关的副本分片。</p>
<img src="/2021/11/01/Elasticsearch%E8%BF%9B%E9%98%B6/data_write.png" class="">

<p>在客户端收到成功响应时，文档变更已经在主分片和所有副本分片执行完成，变更是安全的。有一些可选的<strong>请求参数</strong>允许您影响这个过程，可能以数据安全为代价提升性能。这些选项很少使用，因为 Elasticsearch 已经很快，但是为了完整起见， 请参考下文：</p>
<ol>
<li><p>consistency</p>
<blockquote>
<p>即一致性。在默认设置下，即使仅仅是在试图执行一个写操作之前，主分片都会要求必须要有规定数量quorum（或者换种说法，也即必须要有大多数）的分片副本处于活跃可用状态，才会去执行写操作（其中分片副本 可以是主分片或者副本分片）。这是为了避免在发生网络分区故障（network partition）的时候进行写操作，进而导致数据不一致。 规定数量即： <strong>int((primary + number_of_replicas) / 2 ) + 1</strong></p>
</blockquote>
<pre><code>  consistency 参数的值可以设为：
      one ：只要主分片状态 ok 就允许执行写操作。
      all：必须要主分片和所有副本分片的状态没问题才允许执行写操作。
      quorum：默认值为quorum , 即大多数的分片副本状态没问题就允许执行写操作。
</code></pre>
<p>   注意，规定数量的计算公式中number_of_replicas指的是在索引设置中的设定副本分片数，而不是指当前处理    活动状态的副本分片数。如果你的索引设置中指定了当前索引拥有3个副本分片，那规定数量的计算结果即：               int((1 primary + 3 replicas) / 2) + 1 = 3，如果此时你只启动两个节点，那么处于活跃状态的分片副本数量就达    不到规定数量，也因此您将无法索引和删除任何文档。</p>
</li>
<li><p>timeout<br>如果没有足够的副本分片会发生什么？Elasticsearch 会等待，希望更多的分片出现。默认情况下，它最多等待 1 分钟。 如果你需要，你可以使用timeout参数使它更早终止：100是100 毫秒，30s是30秒。</p>
</li>
</ol>
<p>新索引默认有1个副本分片，这意味着为满足规定数量应该需要两个活动的分片。 但是，这些默认的设置会阻止我们在单一节点上做任何事情。为了避免这个问题，要求只有当number_of_replicas 大于1的时候，规定数量才会执行。</p>
<h3 id="4-2-数据读流程"><a href="#4-2-数据读流程" class="headerlink" title="4.2 数据读流程"></a>4.2 数据读流程</h3><img src="/2021/11/01/Elasticsearch%E8%BF%9B%E9%98%B6/data_read.png" class="">

<p>在处理读取请求时，协调结点在每次请求的时候都会通过轮询所有的副本分片来达到负载均衡。在文档被检索时，已经被索引的文档可能已经存在于主分片上但是还没有复制到副本分片。 在这种情况下，副本分片可能会报告文档不存在，但是主分片可能成功返回文档。 一旦索引请求成功返回给用户，文档在主分片和副本分片都是可用的。</p>
<h3 id="4-3-数据更新流程"><a href="#4-3-数据更新流程" class="headerlink" title="4.3 数据更新流程"></a>4.3 数据更新流程</h3><h4 id="4-3-1-更新流程"><a href="#4-3-1-更新流程" class="headerlink" title="4.3.1 更新流程"></a>4.3.1 更新流程</h4><p>部分更新一个文档结合了先前说明的读取和写入流程：</p>
<img src="/2021/11/01/Elasticsearch%E8%BF%9B%E9%98%B6/data_update.png" class="">

<ol>
<li>客户端向Node 1发送更新请求。</li>
<li>它将请求转发到主分片所在的Node 3 。</li>
<li>Node 3从主分片检索文档，修改_source字段中的JSON，并且尝试重新索引主分片的文档。如果文档已经被另一个进程修改,它会重试步骤3 ,超过retry_on_conflict次后放弃。</li>
<li>如果 Node 3成功地更新文档，它将新版本的文档并行转发到Node 1和 Node 2上的副本分片，重新建立索引。一旦所有副本分片都返回成功，Node 3向协调节点也返回成功，协调节点向客户端返回成功。</li>
</ol>
<p>当主分片把更改转发到副本分片时， 它不会转发更新请求。 相反，它转发完整文档的新版本。请记住，这些更改将会异步转发到副本分片，并且不能保证它们以发送它们相同的顺序到达。 如果 Elasticsearch 仅转发更改请求，则可能以错误的顺序应用更改，导致得到损坏的文档。</p>
<h4 id="4-3-2-批量操作流程"><a href="#4-3-2-批量操作流程" class="headerlink" title="4.3.2 批量操作流程"></a>4.3.2 批量操作流程</h4><p><strong>mget和 bulk API的模式类似于单文档模式。</strong>区别在于协调节点知道每个文档存在于哪个分片中。它将整个多文档请求分解成每个分片的多文档请求，并且将这些请求并行转发到每个参与节点。</p>
<p>协调节点一旦收到来自每个节点的应答，就将每个节点的响应收集整理成单个响应，返回给客户端。</p>
<p><strong>用单个 mget 请求取回多个文档所需的步骤顺序:</strong></p>
<img src="/2021/11/01/Elasticsearch%E8%BF%9B%E9%98%B6/data_update1.png" class="">

<ol>
<li>客户端向 Node 1 发送 mget 请求。</li>
<li>Node 1为每个分片构建多文档获取请求，然后并行转发这些请求到托管在每个所需的主分片或者副本分片的节点上。一旦收到所有答复，Node 1 构建响应并将其返回给客户端。</li>
</ol>
<p>可以对docs数组中每个文档设置routing参数。</p>
<p>bulk API， 允许在单个批量请求中执行多个创建、索引、删除和更新请求。</p>
<p><strong>bulk API 步骤顺序执行：</strong></p>
<img src="/2021/11/01/Elasticsearch%E8%BF%9B%E9%98%B6/data_update2.png" class="">

<ol>
<li>客户端向Node 1 发送 bulk请求。</li>
<li>Node 1为每个节点创建一个批量请求，并将这些请求并行转发到每个包含主分片的节点主机。</li>
<li>主分片一个接一个按顺序执行每个操作。当每个操作成功时,主分片并行转发新文档（或删除）到副本分片，然后执行下一个操作。一旦所有的副本分片报告所有操作成功，该节点将向协调节点报告成功，协调节点将这些响应收集整理并返回给客户端。</li>
</ol>
<h2 id="五-文档"><a href="#五-文档" class="headerlink" title="五. 文档"></a>五. 文档</h2><h3 id="5-1-倒排索引"><a href="#5-1-倒排索引" class="headerlink" title="5.1 倒排索引"></a>5.1 倒排索引</h3><p>传统的数据库每个字段存储单个值，但这对全文检索并不够。文本字段中的每个单词需要被搜索，对数据库意味着需要单个字段有索引多值的能力。最好的支持是一个字段多个值需求的数据结构是<strong>倒排索引</strong>。</p>
<p>Elasticsearch使用一种称为倒排索引的结构，它适用于快速的全文搜索。所谓的倒排索引是将文件ID对应到关键词的映射转换为关键词到文件ID的映射，每个关键词都对应着一系列的文件，这些文件中都出现这个关键词。</p>
<p>一个倒排索引由文档中所有不重复词的列表构成，对于其中每个词，有一个包含它的文档列表。例如，假设我们有两个文档，每个文档的content域包含如下内容：</p>
<ul>
<li>The quick brown fox jumped over the lazy dog</li>
<li>Quick brown foxes leap over lazy dogs in summer</li>
</ul>
<p>为了创建倒排索引，我们首先将每个文档的content域拆分成单独的词（我们称它为词条或tokens )，创建一个包含所有不重复词条的排序列表，然后列出每个词条出现在哪个文档。结果如下所示：</p>
<img src="/2021/11/01/Elasticsearch%E8%BF%9B%E9%98%B6/daopai.png" class="">

<h4 id="5-1-1-不可变的倒排索引"><a href="#5-1-1-不可变的倒排索引" class="headerlink" title="5.1.1 不可变的倒排索引"></a>5.1.1 不可变的倒排索引</h4><p>早期的全文检索会为整个文档集合建立一个很大的倒排索引并将其写入到磁盘。</p>
<p>倒排索引被写入磁盘后是不可改变的：它永远不会修改。</p>
<ol>
<li>不需要锁。如果你从来不更新索引，你就不需要担心多进程同时修改数据的问题。</li>
<li>一旦索引被读入内核的文件系统缓存，便会留在哪里，由于其不变性。只要文件系统缓存中还有足够的空间，那么大部分读请求会直接请求内存，而不会命中磁盘。这提供了很大的性能提升。</li>
<li>其它缓存(像filter缓存)，在索引的生命周期内始终有效。它们不需要在每次数据改变时被重建，因为数据不会变化。</li>
<li>写入单个大的倒排索引允许数据被压缩，减少磁盘IO和需要被缓存到内存的索引的使用量。</li>
</ol>
<p>当然，一个不变的索引也有不好的地方。主要事实是它是不可变的! 你不能修改它。如果你需要让一个新的文档可被搜索，你需要重建整个索引。这要么对一个索引所能包含的数据量造成了很大的限制，要么对索引可被更新的频率造成了很大的限制。</p>
<h4 id="5-1-2-动态更新索引"><a href="#5-1-2-动态更新索引" class="headerlink" title="5.1.2 动态更新索引"></a>5.1.2 动态更新索引</h4><p>如何在保留不变性的前提下实现倒排索引的更新？</p>
<p>答案是：用更多的索引。通过增加新的补充索引来反映新近的修改，而不是直接重写整个倒排索引。每一个倒排索引都会被轮流查询到,从最早的开始查询完后再对结果进行合并。</p>
<p>Elasticsearch基于Lucene，这个java库引入了<strong>按段搜索</strong>的概念。每一段本身都是一个倒排索引，但索引在 Lucene 中除表示所有段的集合外，还增加了提交点的概念—一个列出了所有已知段的文件。</p>
<img src="/2021/11/01/Elasticsearch%E8%BF%9B%E9%98%B6/commit_point.png" class="">

<p>按段搜索会以如下流程执行：</p>
<ol>
<li><p>新文档被收集到内存索引缓存。</p>
<img src="/2021/11/01/Elasticsearch%E8%BF%9B%E9%98%B6/commit_point1.png" class=""></li>
<li><p>不时地, 缓存被提交</p>
<ol>
<li>一个新的段，一个追加的倒排索引，被写入磁盘。</li>
<li>一个新的包含新段名字的提交点被写入磁盘。</li>
<li>磁盘进行同步，所有在文件系统缓存中等待的写入都刷新到磁盘，以确保它们被写入物理文件</li>
</ol>
</li>
<li><p>新的段被开启，让它包含的文档可见以被搜索。</p>
</li>
<li><p>内存缓存被清空，等待接收新的文档。</p>
<img src="/2021/11/01/Elasticsearch%E8%BF%9B%E9%98%B6/commit_point2.png" class=""></li>
</ol>
<p>当一个查询被触发，所有已知的段按顺序被查询。词项统计会对所有段的结果进行聚合，以保证每个词和每个文档的关联都被准确计算。这种方式可以用相对较低的成本将新文档添加到索引。<br>段是不可改变的，所以既不能从把文档从旧的段中移除，也不能修改旧的段来进行反映文档的更新。取而代之的是，每个提交点会包含一个.del 文件，文件中会列出这些被删除文档的段信息。<br>一个<strong>文档被“删除”</strong>时，它实际上只是在 .del 文件中被标记删除。一个被标记删除的文档仍然可以被查询匹配到，但它会在最终结果被返回前从结果集中移除。<br><strong>文档更新</strong>也是类似的操作方式:当一个文档被更新时，旧版本文档被标记删除，文档的新版本被索引到一个新的段中。可能两个版本的文档都会被一个查询匹配到，但被删除的那个旧版本文档在结果集返回前就已经被移除。</p>
<h3 id="5-2-文档刷新"><a href="#5-2-文档刷新" class="headerlink" title="5.2 文档刷新"></a>5.2 文档刷新</h3><img src="/2021/11/01/Elasticsearch%E8%BF%9B%E9%98%B6/doc.png" class="">

<img src="/2021/11/01/Elasticsearch%E8%BF%9B%E9%98%B6/doc1.png" class="">

<h4 id="5-2-1-近实时搜索"><a href="#5-2-1-近实时搜索" class="headerlink" title="5.2.1 近实时搜索"></a>5.2.1 近实时搜索</h4><p>随着按段（per-segment）搜索的发展，一个新的文档从索引到可被搜索的延迟显著降低了。新文档在几分钟之内即可被检索，但这样还是不够快。磁盘在这里成为了瓶颈。提交（Commiting）一个新的段到磁盘需要一个fsync来确保段被物理性地写入磁盘，这样在断电的时候就不会丢失数据。但是fsync操作代价很大；如果每次索引一个文档都去执行一次的话会造成很大的性能问题。</p>
<p>我们需要的是一个更轻量的方式来使一个文档可被搜索，这意味着fsync要从整个过程中被移除。在Elasticsearch和磁盘之间是文件系统缓存。像之前描述的一样，在内存索引缓冲区中的文档会被写入到一个新的段中。但是这里新段会被先写入到文件系统缓存—这一步代价会比较低，稍后再被刷新到磁盘—这一步代价比较高。不过只要文件已经在缓存中，就可以像其它文件一样被打开和读取了。</p>
<img src="/2021/11/01/Elasticsearch%E8%BF%9B%E9%98%B6/commit_point1.png" class="">

<p>Lucene允许新段被写入和打开，使其包含的文档在未进行一次完整提交时便对搜索可见。这种方式比进行一次提交代价要小得多，并且在不影响性能的前提下可以被频繁地执行。</p>
<img src="/2021/11/01/Elasticsearch%E8%BF%9B%E9%98%B6/commit_point3.png" class="">

<p>在 Elasticsearch 中，写入和打开一个新段的轻量的过程叫做refresh。默认情况下每个分片会每秒自动刷新一次。这就是为什么我们说 Elasticsearch是近实时搜索：文档的变化并不是立即对搜索可见，但会在一秒之内变为可见。</p>
<p>这些行为可能会对新用户造成困惑：他们索引了一个文档然后尝试搜索它，但却没有搜到。这个问题的解决办法是用refresh API执行一次手动刷新：/usersl_refresh</p>
<p>尽管刷新是比提交轻量很多的操作，它还是会有性能开销。当写测试的时候，手动刷新很有用，但是不要在生产环境下每次索引一个文档都去手动刷新。相反，你的应用需要意识到Elasticsearch 的近实时的性质，并接受它的不足。</p>
<p>并不是所有的情况都需要每秒刷新。可能你正在使用Elasticsearch索引大量的日志文件，你可能想优化索引速度而不是近实时搜索，可以通过设置refresh_interval ，降低每个索引的刷新频率</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;settings&quot;</span>: &#123;</span><br><span class="line">    	<span class="attr">&quot;refresh_interval&quot;</span>: <span class="string">&quot;30s&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>refresh_interval可以在既存索引上进行动态更新。在生产环境中，当你正在建立一个大的新索引时，可以先关闭自动刷新，待开始使用该索引时，再把它们调回来。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 关闭自动刷新</span><br><span class="line">PUT /users/_settings</span><br><span class="line">&#123; &quot;refresh_interval&quot;: -1 &#125;</span><br><span class="line"></span><br><span class="line"># 每一秒刷新</span><br><span class="line">PUT /users/_settings</span><br><span class="line">&#123; &quot;refresh_interval&quot;: &quot;1s&quot; &#125;</span><br></pre></td></tr></table></figure>

<h4 id="5-2-2-持久化变更"><a href="#5-2-2-持久化变更" class="headerlink" title="5.2.2 持久化变更"></a>5.2.2 持久化变更</h4><p>如果没有用fsync把数据从文件系统缓存刷（flush）到硬盘，我们不能保证数据在断电甚至是程序正常退出之后依然存在。为了保证Elasticsearch 的可靠性，需要确保数据变化被持久化到磁盘。在动态更新索引，我们说一次完整的提交会将段刷到磁盘，并写入一个包含所有段列表的提交点。Elasticsearch 在启动或重新打开一个索引的过程中使用这个提交点来判断哪些段隶属于当前分片。</p>
<p>即使通过每秒刷新(refresh）实现了近实时搜索，我们仍然需要经常进行完整提交来确保能从失败中恢复。但在两次提交之间发生变化的文档怎么办?我们也不希望丢失掉这些数据。Elasticsearch 增加了一个translog ，或者叫事务日志，在每一次对Elasticsearch进行操作时均进行了日志记录。</p>
<p><strong>整个流程如下:</strong></p>
<ol>
<li><p>一个文档被索引之后，就会被添加到内存缓冲区，并且追加到了 translog</p>
<img src="/2021/11/01/Elasticsearch%E8%BF%9B%E9%98%B6/commit_point4.png" class=""></li>
<li><p>刷新（refresh）使分片每秒被刷新（refresh）一次：</p>
<ul>
<li><p>这些在内存缓冲区的文档被写入到一个新的段中，且没有进行fsync操作。</p>
</li>
<li><p>这个段被打开，使其可被搜索。</p>
</li>
<li><p>内存缓冲区被清空。</p>
</li>
</ul>
<img src="/2021/11/01/Elasticsearch%E8%BF%9B%E9%98%B6/commit_point5.png" class=""></li>
<li><p>这个进程继续工作，更多的文档被添加到内存缓冲区和追加到事务日志。</p>
<img src="/2021/11/01/Elasticsearch%E8%BF%9B%E9%98%B6/commit_point6.png" class=""></li>
<li><p>每隔一段时间—例如translog变得越来越大，索引被刷新（flush）；一个新的translog被创建，并且一个全量提交被执行。</p>
<ul>
<li>所有在内存缓冲区的文档都被写入一个新的段。</li>
<li>缓冲区被清空。</li>
<li>一个提交点被写入硬盘。</li>
<li>文件系统缓存通过fsync被刷新（flush） 。</li>
<li>老的translog被删除。</li>
</ul>
</li>
</ol>
<p>translog 提供所有还没有被刷到磁盘的操作的一个持久化纪录。当Elasticsearch启动的时候，它会从磁盘中使用最后一个提交点去恢复己知的段，并且会重放translog 中所有在最后一次提交后发生的变更操作。</p>
<p>translog 也被用来提供实时CRUD。当你试着通过ID查询、更新、删除一个文档，它会在尝试从相应的段中检索之前，首先检查 translog任何最近的变更。这意味着它总是能够实时地获取到文档的最新版本。</p>
<img src="/2021/11/01/Elasticsearch%E8%BF%9B%E9%98%B6/commit_point7.png" class="">

<p>执行一个提交并且截断translog 的行为在 Elasticsearch被称作一次flush。分片每30分钟被自动刷新（flush)，或者在 translog 太大的时候也会刷新。</p>
<p>你很少需要自己手动执行flush操作，通常情况下，自动刷新就足够了。这就是说，在重启节点或关闭索引之前执行 flush有益于你的索引。当Elasticsearch尝试恢复或重新打开一个索引，它需要重放translog中所有的操作，所以如果日志越短，恢复越快。</p>
<p>translog 的目的是保证操作不会丢失，在文件被fsync到磁盘前，被写入的文件在重启之后就会丢失。默认translog是每5秒被fsync刷新到硬盘，或者在每次写请求完成之后执行（e.g. index, delete, update, bulk）。这个过程在主分片和复制分片都会发生。最终，基本上，这意味着在整个请求被fsync到主分片和复制分片的translog之前，你的客户端不会得到一个200 OK响应。</p>
<p>在每次请求后都执行一个fsync会带来一些性能损失，尽管实践表明这种损失相对较小（特别是 bulk 导入，它在一次请求中平摊了大量文档的开销）。</p>
<p>但是对于一些大容量的偶尔丢失几秒数据问题也并不严重的集群，使用异步的 fsync还是比较有益的。比如，写入的数据被缓存到内存中，再每5秒执行一次 fsync 。如果你决定使用异步translog 的话，你需要保证在发生 crash 时，丢失掉 sync_interval时间段的数据也无所谓。请在决定前知晓这个特性。如果你不确定这个行为的后果，最好是使用默认的参数{“index.translog.durability”: “request”}来避免数据丢失。</p>
<h3 id="5-3-段合并"><a href="#5-3-段合并" class="headerlink" title="5.3 段合并"></a>5.3 段合并</h3><p>由于自动刷新流程每秒会创建一个新的段，这样会导致短时间内的段数量暴增。而段数目太多会带来较大的麻烦。每一个段都会消耗文件句柄、内存和 cpu运行周期。更重要的是，每个搜索请求都必须轮流检查每个段；所以段越多，搜索也就越慢。<br>Elasticsearch通过在后台进行段合并来解决这个问题。小的段被合并到大的段，然后这些大的段再被合并到更大的段。<br>段合并的时候会将那些旧的已删除文档从文件系统中清除。被删除的文档（或被更新文档的旧版本）不会被拷贝到新的大段中。<br>启动段合并不需要你做任何事。进行索引和搜索时会自动进行。</p>
<ol>
<li><p>当索引的时候，刷新（refresh）操作会创建新的段并将段打开以供搜索使用。</p>
</li>
<li><p>合并进程选择一小部分大小相似的段，并且在后台将它们合并到更大的段中。这并不会中断索引和搜索。</p>
<img src="/2021/11/01/Elasticsearch%E8%BF%9B%E9%98%B6/merger.png" class=""></li>
<li><p>一旦合并结束，老的段被删除</p>
<ul>
<li>新的段被刷新(flush)到了磁盘。</li>
<li>写入一个包含新段且排除旧的和较小的段的新提交点。</li>
<li>新的段被打开用来搜索。老的段被删除。</li>
</ul>
 <img src="/2021/11/01/Elasticsearch%E8%BF%9B%E9%98%B6/merger1.png" class=""></li>
</ol>
<p>合并大的段需要消耗大量的 I/O 和 CPU 资源，如果任其发展会影响搜索性能。 Elasticsearch在默认情况下会对合并流程进行资源限制，所以搜索仍然有足够的资源很好地执行。</p>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Elasticsearch/" rel="tag"># Elasticsearch</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2021/10/28/ES%E6%8E%A5%E5%8F%A3%E6%93%8D%E4%BD%9C/" rel="prev" title="ES接口操作">
                  <i class="fa fa-chevron-left"></i> ES接口操作
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2021/11/15/MQ%E6%A6%82%E8%BF%B0/" rel="next" title="MQ概述">
                  MQ概述 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">xys-colin</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  
<script src="https://cdn.jsdelivr.net/npm/hexo-generator-searchdb@1.4.0/dist/search.js" integrity="sha256-vXZMYLEqsROAXkEw93GGIvaB2ab+QW6w3+1ahD9nXXA=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>





  





</body>
</html>
